<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
<title>Sylvester Test Suite</title>
<script src="../lib/sylvester.js" type="text/javascript"></script>
<script src="test.js" type="text/javascript"></script>
<link rel="stylesheet" type="text/css" href="test.css" />
<script type="text/javascript">

var summary, i, A, V, V1, V2, M, M1, M2, L, L1, L2, P, P1, P2;
var begin = new Date().getTime();

window.onload = function() {

  resultList = document.getElementById('results');
  
  title('Setup');
  assert('Test assertion', true);
  
  title('Line tests');
  
  assert('Equality of antiparallel lines',
    Line.X.eql($L([0,0,0], [-12,0,0]))
  );
  
  assert('Line translation',
    Line.X.dup().translate([0,0,12]).eql($L([0,0,12], Vector.i))
  );
  
  assert('Parallelity',
    Line.X.isParallelTo($L([0,0,-12], [-4,0,0]))
  );
  
  for (i = 1; i <= 10; i++) {
    var O = $V([-5,-5,-5]);
    V = O.add(Vector.Random(3).x(10));
    V1 = O.add(Vector.Random(3).x(10));
    V2 = O.add(Vector.Random(3).x(10));
    L1 = $L(V, V1);
    L2 = $L(V.add(V1.x(-20 + 40*Math.random())), V2);
    V = L1.intersectionWith(L2);
    p = V.subtract(L2.anchor), q = L2.direction;
    assert('Intersection test ' + i,
      L1.contains(V) && L2.contains(V),
      ' Intersection: ' + V.inspect() + '\n\nDistance from L1: ' + L1.distanceFrom(V) + ', from L2: ' + L2.distanceFrom(V)
    );
  }
  
  assert('Position of point',
    $L([0,0,0], [1,1,-1]).positionOf([3,3,-3]) - Math.sqrt(27) <= Sylvester.precision,
    $L([0,0,0], [1,1,-1]).positionOf([3,3,-3])
  );
  
  assert('Find closest point to a point',
    Line.X.pointClosestTo($V([26,-2,18])).eql($V([26,0,0]))
  );
  
  assert('Distance from a line',
    $L([0,0,0], [1,0,0]).distanceFrom($L([0,0,24], [1,1,0])) == 24,
    $L([0,0,0], [1,0,0]).distanceFrom($L([0,0,24], [1,1,0]))
  );
  
  assert('Distance from a plane',
    $L([12,0,0], Vector.k).distanceFrom(Plane.YZ) == 12,
    $L([12,0,0], Vector.k).distanceFrom(Plane.YZ)
  );
  
  assert('Distance from an intersecting plane',
    $L([12,0,0], [1,0,200]).distanceFrom(Plane.YZ) === 0,
    $L([12,0,0], [1,0,200]).distanceFrom(Plane.YZ)
  );
  
  assert('Closest point to a line',
    $L([0,0,0], [1,0,0]).pointClosestTo($L([0,0,24], [1,1,0])).eql($V([0,0,0])),
    $L([0,0,0], [1,0,0]).pointClosestTo($L([0,0,24], [1,1,0])).inspect()
  );
  
  assert('Closest point to a line, reversed',
    $L([0,0,24], [1,1,0]).pointClosestTo($L([0,0,0], [-1,0,0])).eql($V([0,0,24])),
    $L([0,0,24], [1,1,0]).pointClosestTo($L([0,0,0], [-1,0,0])).inspect()
  );
  
  assert('Reflection in a point',
    Line.Z.reflectionIn($V([28,0,-12])).eql($L([56,0,0], Vector.k.x(-1)))
  );
  
  assert('Reflection in a line',
    Line.X.reflectionIn($L([0,0,0],[1,0,1])).eql(Line.Z)
  );
  
  L1 = Line.X.dup();
  L2 = $L([5,0,0], Vector.k);
  assert('Reflection in a plane',
    L1.reflectionIn($P([5,0,0], [1,0,1])).eql(L2)
  );
  assert('Reflection in a plane, reversed',
    L2.reflectionIn($P([5,0,0], [1,0,1])).eql(L1)
  );
  
  assert('Rotation',
    Line.X.rotate(Math.PI, $L([12,0,0],[1,0,1])).eql($L([12,0,0], Vector.k))
  );
  
  assert('Rotation again',
    $L([10,0,0], [0,1,1]).rotate(-Math.PI/2, Line.Y).eql($L([0,0,10], [1,-1,0]))
  );
  
  assert('2D rotation, about a point',
    $L([9,0], Vector.j).rotate(Math.PI/2, $V([9,9])).eql($L([0,9], Vector.i))
  );
  
  assert('2D intersection',
    $L([5,0], [0,1]).intersectionWith($L([0,0], [-1,-1])).eql($V([5,5,0])),
    $L([5,0], [0,1]).intersectionWith($L([0,0], [-1,-1])).inspect()
  );
  
  assert('2D reflection',
    $L([-4,3], [0,-1]).reflectionIn($V([0,0])).eql($L([4,100], [0,4]))
  );
  
  assert('Parallel to plane',
    Line.X.isParallelTo($P([0,0,-4], Vector.k))
  );
  
  title('Line segment tests');
  
  assert('Line contains line segment',
    $L([0,0,0], [1,1,1]).contains(Line.Segment.create([-2,-2,-2], [13,13,13]))
  );
  
  L1 = Line.Segment.create([5,5,5], [10,10,10]);
  
  assert('Line segment length',
    L1.length() - Math.sqrt(75) <= Sylvester.precision,
    L1.length() - Math.sqrt(75)
  );
  
  assert('Conversion to vector',
    L1.toVector().eql([5,5,5])
  );
  
  assert('Midpoint',
    L1.midpoint().eql([7.5,7.5,7.5])
  );
  
  assert('Bisecting plane',
    L1.bisectingPlane().eql($P([7.5,7.5,7.5], [1,1,1]))
  );
  
  assert('Contains its midpoint',
    L1.contains(L1.midpoint())
  );
  
  assert('Contains its start point',
    L1.contains([5,5,5])
  );
  
  assert('Contains its end point',
    L1.contains([10,10,10])
  );
  
  assert('Does not contain points outside its ends',
    !L1.contains([4.9999,4.9999,4.9999]) && !L1.contains([10.00001, 10.00001, 10.00001])
  );
  
  assert('Does not intersect various things that it would intersect at infinite length',
    !L1.intersects(Line.X) && !L1.intersects(Line.Y) && !L1.intersects(Line.Z) &&
    !L1.intersects(Plane.XY) && !L1.intersects(Plane.YZ) && !L1.intersects(Plane.ZX)
  );
  
  assert('Intersection with bisecting plane',
    L1.intersectionWith(L1.bisectingPlane()).eql(L1.midpoint())
  );
  
  L2 = Line.Segment.create([1,1,0], [1,2,0]);
  
  assert('No point closest to line',
    L2.pointClosestTo(Line.Y) === null
  );
  
  assert('Point closest to line 1',
    L2.pointClosestTo(Line.X).eql([1,1,0])
  );
  
  assert('Point closest to line 2',
    L2.pointClosestTo(Line.X.translate([0,10])).eql([1,2,0])
  );
  
  assert('Point closest to line 3',
    L2.pointClosestTo($L([0,1.5,0], [0,0,1])).eql([1,1.5,0])
  );
  
  assert('Point closest to plane',
    L2.pointClosestTo(Plane.XZ).eql([1,1,0])
  );
  
  assert('No point closest to plane',
    L2.pointClosestTo(Plane.YZ) === null
  );
  
  title('Plane tests');
  
  assert('Equality and duplication',
    Plane.XY.dup().eql($P([34,-99,0], [0,0,-4]))
  );
  
  assert('Translation',
    Plane.XY.dup().translate([5,12,-14]).eql($P([89,-34,-14], Vector.k))
  );
  
  assert('Parallel to plane',
    Plane.XY.dup().translate([5,12,-14]).isParallelTo(Plane.XY)
  );
  
  assert('Parallel to line',
    Plane.XY.isParallelTo($L([4,8,10], [2,-6,0]))
  );
  
  assert('Distance from plane',
    Plane.XY.dup().translate([5,12,-14]).distanceFrom(Plane.XY) == 14
  );
  
  assert('Distance from intersecting plane',
    Plane.XY.dup().translate([5,12,-14]).distanceFrom($P([0,0,0], [1,0,1])) === 0
  );
  
  assert('Distance from line',
    Plane.XY.distanceFrom($L([4,8,10], [2,-6,0])) == 10
  );
  
  assert('Distance from intersecting line',
    Plane.XY.distanceFrom($L([4,8,10], [2,-6,2])) === 0
  );
  
  assert('Contains line',
    Plane.XY.contains(Line.X)
  );
  
  assert('Contains point',
    Plane.XY.contains(Vector.i)
  );
  
  assert('Closest point',
   Plane.YZ.pointClosestTo($V([3,6,-3])).eql($V([0,6,-3]))
  );
  
  assert('Rotation',
    Plane.XY.rotate(Math.PI/2, Line.Y).eql(Plane.YZ)
  );
  
  assert('Reflection in a point',
    Plane.XY.reflectionIn($V([12,65,-4])).eql($P([0,0,-8], Vector.k))
  );
  
  assert('Reflection in a perpendicular line',
    Plane.XY.reflectionIn(Line.Z).eql(Plane.XY)
  );
  
  assert('Reflection in some line',
    Plane.XY.reflectionIn($L([0,0,0], [1,0,1])).eql(Plane.YZ)
  );
  
  assert('Reflection in a plane',
     $P([5,0,0], [1,1,0]).reflectionIn($P([5,0,0], [0,1,0])).eql($P([5,0,0], [-1,1,0]))
  );
  
  assert('Reflection in a plane, cycled',
     $P([0,5,0], [0,1,1]).reflectionIn($P([0,5,0], [0,0,1])).eql($P([0,5,0], [0,-1,1]))
  );
  
  assert('Reflection in a plane, cycled again',
     $P([0,0,5], [1,0,1]).reflectionIn($P([0,0,5], [1,0,0])).eql($P([0,0,5], [1,0,-1]))
  );
  
  for (i = 1; i <= 10; i++) {
    P1 = $P($V([-50,-50,-50]).add(Vector.Random(3).x(100)), $V([-50,-50,-50]).add(Vector.Random(3).x(100)));
    P2 = $P($V([-50,-50,-50]).add(Vector.Random(3).x(100)), $V([-50,-50,-50]).add(Vector.Random(3).x(100)));
    if (P1.intersects(P2)) {
      L1 = P1.intersectionWith(P2);
      L2 = P2.intersectionWith(P1);
      assert('Intersection test ' + i,
        L1.eql(L2) && L1.liesIn(P1) && P2.contains(L1)
      );
    }
  }
  
  summary = document.getElementById('summary');
  var fin = new Date().getTime();
  var time = fin - begin;
  summary.innerHTML = 'Tests completed in ' + time/1000 + ' seconds. ' + nTests + ' assertions, ' + nFailures + ' failures.';
};

</script>
</head>
<body>

<h1>Sylvester Test Suite</h1>

<p id="summary"></p>

<ul id="results">
</ul>

</body>
</html>
